// Generated by CoffeeScript 1.12.6
var AlgebraicOperand, ExpressionBlock, Operand, bestOperand, findOperator, format, mathFuncs, operandTypes, operators, parseExpr,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

format = require('string-format');

format.extend(String.prototype);

bestOperand = function(expr) {
  var c, i, len, opt, possible;
  possible = [];
  for (i = 0, len = operandTypes.length; i < len; i++) {
    opt = operandTypes[i];
    if (opt.test(expr)) {
      possible.push(opt);
    }
  }
  c = possible.sort(function(ot, ot2) {
    return ot2.score - ot.score;
  })[0];
  return new c(expr);
};

findOperator = function(char) {
  var i, len, o;
  for (i = 0, len = operators.length; i < len; i++) {
    o = operators[i];
    if (indexOf.call(o.chars, char) >= 0) {
      return o;
    }
  }
  return null;
};

ExpressionBlock = (function() {
  function ExpressionBlock(left, char1, right) {
    this.left = left;
    this.char = char1;
    this.right = right;
    this.stepSolve = bind(this.stepSolve, this);
    this.solve = bind(this.solve, this);
    this.valueOf = bind(this.valueOf, this);
  }

  ExpressionBlock.prototype.valueOf = function() {
    return this.solve();
  };

  ExpressionBlock.prototype.solve = function() {
    var l, r, res;
    l = this.left;
    while (typeof l === "object" && (l.solve != null)) {
      l = l.solve();
    }
    r = this.right;
    while (typeof r === "object" && (r.solve != null)) {
      r = r.solve();
    }
    res = l.operate(this, [l, r], this.char);
    return res;
  };

  ExpressionBlock.prototype.stepSolve = function(stepFunc) {
    var i, j, l, len, len1, r, ref, ref1, res, step, x;
    l = this.left;
    while (l.stepSolve != null) {
      l = l.stepSolve(stepFunc);
    }
    r = this.right;
    if (r != null) {
      while (r.stepSolve != null) {
        r = r.stepSolve(stepFunc);
      }
    }
    console.log("Solving " + (l != null ? l.value : void 0) + " " + this.char + " " + (r != null ? r.value : void 0) + "...");
    if (r != null) {
      res = l.operate(this, [l, r], this.char);
    } else {
      res = l.operate(this, [l], this.char);
    }
    if (res.solve != null) {
      res = res.stepSolve(stepFunc);
    }
    if (stepFunc != null) {
      step = [];
      if (r != null) {
        ref = findOperator(this.char).step;
        for (i = 0, len = ref.length; i < len; i++) {
          x = ref[i];
          if (typeof x === "function") {
            step.push(x(l.value, r.value, res.value));
          } else {
            step.push(x.format({
              l: l.value,
              r: r.value,
              result: res.value
            }));
          }
        }
      } else {
        ref1 = findOperator(this.char).step;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          x = ref1[j];
          if (typeof x === "function") {
            step.push(x(l.value, null, res.value));
          } else {
            step.push(x.format({
              l: l.value,
              r: null,
              result: res.value
            }));
          }
        }
      }
      stepFunc(step.join("\n"));
    }
    return res;
  };

  return ExpressionBlock;

})();

Operand = (function() {
  function Operand(value) {
    this.value = value;
    this.valueOf = bind(this.valueOf, this);
    this.toString = bind(this.toString, this);
    this.operate = bind(this.operate, this);
  }

  Operand.score = 0;

  Operand.test = function(expr) {
    return true;
  };

  Operand.prototype.operating = function(block, others, caller, char) {};

  Operand.prototype.precedence = function(char) {
    var op;
    op = findOperator(char);
    return op.precedence;
  };

  Operand.prototype.operate = function(block, others, char) {
    var i, len, o, op;
    op = findOperator(char);
    for (i = 0, len = others.length; i < len; i++) {
      o = others[i];
      if (!o === this) {
        o.operating(others, this, char);
      }
    }
    return bestOperand(op.solver.apply(this, others));
  };

  Operand.prototype.toString = function() {
    return this.value.toString();
  };

  Operand.prototype.valueOf = function() {
    return +this.value;
  };

  return Operand;

})();

AlgebraicOperand = (function(superClass) {
  extend(AlgebraicOperand, superClass);

  function AlgebraicOperand(value) {
    var a, groups;
    this.value = value;
    this.valueOf = bind(this.valueOf, this);
    this.operate = bind(this.operate, this);
    this.operating = bind(this.operating, this);
    groups = this.value.match(new RegExp("(\\d*)[" + [
      (function() {
        var i, len, ref, results;
        ref = operators[0].chars.join('');
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          a = ref[i];
          results.push('\\' + a.toString());
        }
        return results;
      })()
    ] + "]?([a-zA-Z]+)", "i"));
    this.multiplier = groups[1];
    if (this.multiplier === "") {
      this.multiplier = 1;
    }
    this.letters = groups[2];
    this.diff = 0;
    this.exponent = 1;
  }

  AlgebraicOperand.score = 10;

  AlgebraicOperand.test = function(expr) {
    var a, r;
    r = new RegExp("(\\d*)[" + [
      (function() {
        var i, len, ref, results;
        ref = operators[0].chars.join('');
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          a = ref[i];
          results.push('\\' + a.toString());
        }
        return results;
      })()
    ] + "]?([a-zA-Z]+)", "i").test(expr);
    return r;
  };

  AlgebraicOperand.prototype.operating = function(block, others, caller, char) {
    return this.operate(block, others, char);
  };

  AlgebraicOperand.prototype.operate = function(block, others, char) {
    var differences, i, len, o, op, other, othersub, subexp;
    for (i = 0, len = others.length; i < len; i++) {
      o = others[i];
      if (o !== this) {
        other = o;
      }
    }
    if (char === "=") {
      this.definition = Math.pow((+other.value + this.diff) / this.multiplier, 1 / this.exponent);
      return new ExpressionBlock(bestOperand(this.exponent), "$", new ExpressionBlock(new ExpressionBlock(other, "+", bestOperand(this.diff)), "/", bestOperand(this.multiplier)));
    } else if (char === "@") {
      return AlgebraicOperand.__super__.operate.apply(this, arguments).operate(block, others, "@");
    } else {
      subexp = block;
      othersub = [];
      op = findOperator(char);
      differences = "";
      if (others.length === 2) {
        if (op.name === "Power") {
          this.exponent += +other.value - 1;
          return this;
        } else if (op.name === "Root") {
          this.exponent -= +other.value - 1;
          return this;
        } else if (op.name === "Subtraction") {
          this.diff += +other.value;
          return this;
        } else if (op.name === "Sum") {
          this.diff -= +other.value;
          return this;
        } else if (op.name === "Multiplication") {
          this.multiplier /= +other.value;
          return this;
        } else if (op.name === "Division") {
          this.multiplier *= +other.value;
          return this;
        } else {
          throw new Error("Unsupported algebraic operation: '" + char + "'!");
          return this;
        }
      }
    }
  };

  AlgebraicOperand.prototype.valueOf = function(a) {
    if (this.definition != null) {
      return this.definition;
    } else {
      throw new Error(this.value + " is a variable, undefined expression!");
    }
  };

  return AlgebraicOperand;

})(Operand);

mathFuncs = {
  "sin": Math.sin,
  "cos": Math.cos,
  "tan": Math.tan
};

operators = [
  {
    name: "Negation",
    numargs: 1,
    description: "Negate a number.",
    step: ["Negate {l}.", "", "   -{l}"],
    precedence: 7,
    chars: ["'"],
    solver: function(a) {
      return -(+a);
    }
  }, {
    name: "Multiplication",
    numargs: 2,
    description: "Multiply two numbers.",
    step: ["Multiply {l} and {r}:", "", "   {l} × {r} = {result}"],
    precedence: 29,
    chars: ["×", "*"],
    solver: function(a, b) {
      return +a * +b;
    }
  }, {
    name: "Sum",
    numargs: 2,
    description: "Sum two numbers.",
    step: ["Sum {l} and {r}:", "", "   {l} + {r} = {result}"],
    precedence: 30,
    chars: ["+"],
    solver: function(a, b) {
      return +a + +b;
    }
  }, {
    name: "Function",
    numargs: 2,
    description: "Call the math function of some name.",
    step: ["Call {l} on {r}.", "", "   {l}({r}) = {result}"],
    precedence: 5,
    chars: ["@"],
    solver: function(a, b) {
      a = a.toString();
      if (indexOf.call(Object.keys(mathFuncs), a) >= 0) {
        return mathFuncs[a](b);
      } else {
        throw Error("No such function '" + a + "'!");
      }
    }
  }, {
    name: "Equal",
    numargs: 2,
    description: "Define an algebraic variable.",
    step: ["Define {l} equals {r}.", "", "   {l} = {r}; {l} = {result}"],
    precedence: 70,
    chars: ["="],
    solver: function(a, b) {
      return a;
    }
  }, {
    name: "Subtraction",
    numargs: 2,
    description: "Subtract a number by another one.",
    step: ["Subtract {l} by {r}:", "", "   {l} - {r} = {result}"],
    precedence: 30,
    chars: ["-"],
    solver: function(a, b) {
      return +a - +b;
    }
  }, {
    name: "Division",
    numargs: 2,
    description: "Divide a number by another one.",
    step: [
      "Divide {l} by {r}:", "", "   {l}", function(l, r, result) {
        return "   {a} = {result}".format({
          result: result,
          a: "~".repeat(l.length > r.length ? l.length : r.length)
        });
      }, "   {r}"
    ],
    precedence: 29,
    chars: ["/", ":"],
    solver: function(a, b) {
      return +a / +b;
    }
  }, {
    name: "Power",
    numargs: 2,
    description: "Raise a number to the power of some other number.",
    step: ["Raise {l} to the power of {r}:", "", "   {l}´{r} = {result}"],
    precedence: 28,
    chars: ["^", "´"],
    solver: function(a, b) {
      return Math.pow(+a, +b);
    }
  }, {
    name: "Root",
    numargs: 2,
    description: "Perform a n-th root in a variable.",
    step: ["Perform a {l}-root on {r}:", "", "   {l}√{r} = {result}"],
    precedence: 28,
    chars: ["$", "√"],
    solver: function(a, b) {
      return Math.pow(+b, 1 / +a);
    }
  }
];

parseExpr = function(expr) {
  var ch, curr, i, len, op, oper, operands, ops, parens, pos, r, ref, ref1, subexp;
  curr = "";
  subexp = "";
  operands = [];
  oper = null;
  parens = 0;
  pos = 0;
  ops = 0;
  console.log("Parsing " + expr + "...");
  expr = expr.replace(/\s/g, "");
  for (i = 0, len = expr.length; i < len; i++) {
    ch = expr[i];
    if (parens > 0) {
      if (ch === ")") {
        if (parens === 1) {
          r = parseExpr(subexp);
          r.paren = true;
          curr = r;
          operands.push(r);
          subexp = "";
        } else {
          subexp += ch;
        }
        parens--;
      } else {
        if (ch === "(") {
          parens++;
        }
        subexp += ch;
      }
    } else {
      op = findOperator(ch);
      if (op != null) {
        if (op.numargs === 1) {
          if (curr !== "") {
            throw new Error("Unary operator must be at the left side of an operand, not right! (at " + expr + ", operator " + ch + " at position " + pos + ")");
          } else {
            oper = ch;
          }
        } else {
          if (ops === 0) {
            if (curr !== "") {
              if (typeof curr !== "object") {
                operands.push(bestOperand(curr));
              } else {
                operands.push(curr);
              }
              curr = "";
            } else {
              throw new Error("Binary operators need a non-null left value! (at " + expr + ", operator " + ch + " at position " + pos + ")");
            }
            oper = ch;
          } else {
            if (typeof operands[0] === "object" && (operands[0].solve != null)) {
              if (findOperator(operands[0].char).precedence > findOperator(ch).precedence || ((ref = operator[0]) != null ? ref.paren : void 0)) {
                operands = [new ExpressionBlock(operands[0].left, operands[0].char, new ExpressionBlock(operands[0].right, ch, curr))];
              } else {
                operands = [new ExpressionBlock(operands[0], ch, curr)];
              }
            }
          }
        }
        ops++;
      } else {
        if (ch === "(") {
          parens++;
        } else if (ch === ")") {
          throw new Error("Unmatched ')' (at " + expr + ", position " + pos + ")");
        } else {
          curr += ch;
        }
      }
    }
    pos += 1;
  }
  if (typeof curr === "ExpressionBlock") {
    return curr;
  } else {
    if (findOperator(oper).numargs === 1 || (operands[0] == null)) {
      if (curr === "") {
        throw new Error("Unary operators need a single value! (at " + expr + ", operator " + oper + " at position " + pos + ")");
      }
      if (typeof curr !== "object") {
        curr = bestOperand(curr);
      }
      return new ExpressionBlock(curr, oper, void 0);
    } else {
      if (curr === "") {
        throw new Error("Binary operators need a non-null right value! (at " + expr + ", operator " + oper + " at position " + pos + ")");
      }
      if (typeof curr !== "object") {
        curr = bestOperand(curr);
      }
      if (typeof operands[0] === "object" && (operands[0].solve != null)) {
        if (findOperator(operands[0].char).precedence > findOperator(oper).precedence && ((ref1 = operands[0]) != null ? ref1.paren : void 0)) {
          return new ExpressionBlock(operands[0].left, operands[0].char, new ExpressionBlock(operands[0].right, oper, curr));
        } else {
          return new ExpressionBlock(operands[0], oper, curr);
        }
      } else if (typeof operands[0] === "object") {
        return new ExpressionBlock(operands[0], oper, curr);
      } else {
        return new ExpressionBlock(bestOperand(operands[0]), oper, curr);
      }
    }
  }
};

operandTypes = [Operand, AlgebraicOperand];

module.exports = {
  operators: operators,
  parseExpr: parseExpr,
  ExpressionBlock: ExpressionBlock,
  Operand: Operand,
  AlgebraicOperand: AlgebraicOperand,
  findOperator: findOperator,
  bestOperand: bestOperand,
  operandTypes: operandTypes
};
